// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/stakers/v1beta1/stakers.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Staker contains all metadata for a staker
// Every address can only create one staker (itself)
type Staker struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// commission ...
	Commission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=commission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"commission"`
	// moniker ...
	Moniker string `protobuf:"bytes,3,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// website ...
	Website string `protobuf:"bytes,4,opt,name=website,proto3" json:"website,omitempty"`
	// identity is the 64 bit keybase.io identity string
	Identity string `protobuf:"bytes,5,opt,name=identity,proto3" json:"identity,omitempty"`
	// security_contact ...
	SecurityContact string `protobuf:"bytes,6,opt,name=security_contact,json=securityContact,proto3" json:"security_contact,omitempty"`
	// details are some additional notes the staker finds important
	Details string `protobuf:"bytes,7,opt,name=details,proto3" json:"details,omitempty"`
	// commission_rewards are the rewards in $KYVE earned through commission
	CommissionRewards uint64 `protobuf:"varint,8,opt,name=commission_rewards,json=commissionRewards,proto3" json:"commission_rewards,omitempty"`
}

func (m *Staker) Reset()         { *m = Staker{} }
func (m *Staker) String() string { return proto.CompactTextString(m) }
func (*Staker) ProtoMessage()    {}
func (*Staker) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{0}
}
func (m *Staker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Staker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Staker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Staker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Staker.Merge(m, src)
}
func (m *Staker) XXX_Size() int {
	return m.Size()
}
func (m *Staker) XXX_DiscardUnknown() {
	xxx_messageInfo_Staker.DiscardUnknown(m)
}

var xxx_messageInfo_Staker proto.InternalMessageInfo

func (m *Staker) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Staker) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Staker) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Staker) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Staker) GetSecurityContact() string {
	if m != nil {
		return m.SecurityContact
	}
	return ""
}

func (m *Staker) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func (m *Staker) GetCommissionRewards() uint64 {
	if m != nil {
		return m.CommissionRewards
	}
	return 0
}

// Valaccount gets authorized by a staker to
// vote in a given pool by favor of the staker.
type Valaccount struct {
	// pool_id defines the pool in which the address
	// is allowed to vote in.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// staker is the address the valaccount is voting for.
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// valaddress is the account stored on the protocol
	// node which votes for the staker in the given pool
	Valaddress string `protobuf:"bytes,3,opt,name=valaddress,proto3" json:"valaddress,omitempty"`
	// When a node is inactive (does not vote at all)
	// A point is added, after a certain amount of points
	// is reached the node gets kicked out.
	Points uint64 `protobuf:"varint,4,opt,name=points,proto3" json:"points,omitempty"`
	// isLeaving indicates if a staker is leaving the given pool.
	IsLeaving bool `protobuf:"varint,5,opt,name=is_leaving,json=isLeaving,proto3" json:"is_leaving,omitempty"`
}

func (m *Valaccount) Reset()         { *m = Valaccount{} }
func (m *Valaccount) String() string { return proto.CompactTextString(m) }
func (*Valaccount) ProtoMessage()    {}
func (*Valaccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{1}
}
func (m *Valaccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Valaccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Valaccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Valaccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Valaccount.Merge(m, src)
}
func (m *Valaccount) XXX_Size() int {
	return m.Size()
}
func (m *Valaccount) XXX_DiscardUnknown() {
	xxx_messageInfo_Valaccount.DiscardUnknown(m)
}

var xxx_messageInfo_Valaccount proto.InternalMessageInfo

func (m *Valaccount) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Valaccount) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *Valaccount) GetValaddress() string {
	if m != nil {
		return m.Valaddress
	}
	return ""
}

func (m *Valaccount) GetPoints() uint64 {
	if m != nil {
		return m.Points
	}
	return 0
}

func (m *Valaccount) GetIsLeaving() bool {
	if m != nil {
		return m.IsLeaving
	}
	return false
}

// CommissionChangeEntry stores the information for an
// upcoming commission change. A commission change is never
// instant, so delegators have time to redelegate in case
// they don't agree with the new commission.
type CommissionChangeEntry struct {
	// index is needed for the queue-algorithm which
	// processes the commission changes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker is the address of the affected staker
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// commission is the new commission which will
	// be applied after the waiting time is over.
	Commission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=commission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"commission"`
	// creation_date is the UNIX-timestamp in seconds
	// when the entry was created.
	CreationDate int64 `protobuf:"varint,4,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
}

func (m *CommissionChangeEntry) Reset()         { *m = CommissionChangeEntry{} }
func (m *CommissionChangeEntry) String() string { return proto.CompactTextString(m) }
func (*CommissionChangeEntry) ProtoMessage()    {}
func (*CommissionChangeEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{2}
}
func (m *CommissionChangeEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommissionChangeEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommissionChangeEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommissionChangeEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommissionChangeEntry.Merge(m, src)
}
func (m *CommissionChangeEntry) XXX_Size() int {
	return m.Size()
}
func (m *CommissionChangeEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_CommissionChangeEntry.DiscardUnknown(m)
}

var xxx_messageInfo_CommissionChangeEntry proto.InternalMessageInfo

func (m *CommissionChangeEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CommissionChangeEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *CommissionChangeEntry) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

// LeavePoolEntry stores the information for an upcoming
// pool leave. A staker can't leave a pool instantly.
// Instead a the `LeaveTime` needs to be awaited.
// If a staker start to leave a pool, it will be shown
// in the UI to the delegators.
type LeavePoolEntry struct {
	// index is needed for the queue-algorithm which
	// processes the commission changes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker is the address of the affected staker
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_id indicates the pool the staker wants to leave
	PoolId uint64 `protobuf:"varint,3,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// creation_date is the UNIX-timestamp in seconds
	// when the entry was created.
	CreationDate int64 `protobuf:"varint,4,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
}

func (m *LeavePoolEntry) Reset()         { *m = LeavePoolEntry{} }
func (m *LeavePoolEntry) String() string { return proto.CompactTextString(m) }
func (*LeavePoolEntry) ProtoMessage()    {}
func (*LeavePoolEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{3}
}
func (m *LeavePoolEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeavePoolEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeavePoolEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeavePoolEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeavePoolEntry.Merge(m, src)
}
func (m *LeavePoolEntry) XXX_Size() int {
	return m.Size()
}
func (m *LeavePoolEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LeavePoolEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LeavePoolEntry proto.InternalMessageInfo

func (m *LeavePoolEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LeavePoolEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *LeavePoolEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *LeavePoolEntry) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

// UnbondingState stores the state for the unbonding of stakes and delegations.
type QueueState struct {
	// low_index is the tail of the queue. It is the
	// oldest entry in the queue. If this entry isn't
	// due, non of the other entries is.
	LowIndex uint64 `protobuf:"varint,1,opt,name=low_index,json=lowIndex,proto3" json:"low_index,omitempty"`
	// high_index is the head of the queue. New entries
	// are added to the top.
	HighIndex uint64 `protobuf:"varint,2,opt,name=high_index,json=highIndex,proto3" json:"high_index,omitempty"`
}

func (m *QueueState) Reset()         { *m = QueueState{} }
func (m *QueueState) String() string { return proto.CompactTextString(m) }
func (*QueueState) ProtoMessage()    {}
func (*QueueState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{4}
}
func (m *QueueState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueState.Merge(m, src)
}
func (m *QueueState) XXX_Size() int {
	return m.Size()
}
func (m *QueueState) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueState.DiscardUnknown(m)
}

var xxx_messageInfo_QueueState proto.InternalMessageInfo

func (m *QueueState) GetLowIndex() uint64 {
	if m != nil {
		return m.LowIndex
	}
	return 0
}

func (m *QueueState) GetHighIndex() uint64 {
	if m != nil {
		return m.HighIndex
	}
	return 0
}

func init() {
	proto.RegisterType((*Staker)(nil), "kyve.stakers.v1beta1.Staker")
	proto.RegisterType((*Valaccount)(nil), "kyve.stakers.v1beta1.Valaccount")
	proto.RegisterType((*CommissionChangeEntry)(nil), "kyve.stakers.v1beta1.CommissionChangeEntry")
	proto.RegisterType((*LeavePoolEntry)(nil), "kyve.stakers.v1beta1.LeavePoolEntry")
	proto.RegisterType((*QueueState)(nil), "kyve.stakers.v1beta1.QueueState")
}

func init() {
	proto.RegisterFile("kyve/stakers/v1beta1/stakers.proto", fileDescriptor_d209d1a2a74d375d)
}

var fileDescriptor_d209d1a2a74d375d = []byte{
	// 537 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x53, 0xdd, 0x6a, 0x13, 0x41,
	0x18, 0xcd, 0x36, 0x69, 0x7e, 0x3e, 0xfc, 0x1d, 0xa2, 0x2e, 0x95, 0x6e, 0x4b, 0x04, 0xa9, 0x60,
	0xb3, 0x14, 0xdf, 0xa0, 0x69, 0xc5, 0xa2, 0x14, 0xdd, 0x42, 0x41, 0x6f, 0xc2, 0x64, 0xf6, 0x63,
	0x33, 0x64, 0x33, 0x13, 0x76, 0x26, 0x49, 0x03, 0x3e, 0x84, 0x17, 0x3e, 0x8b, 0x17, 0x3e, 0x41,
	0x2f, 0x7b, 0x29, 0x5e, 0x14, 0x49, 0x5e, 0x44, 0x66, 0x66, 0x37, 0xdd, 0x5e, 0x08, 0xa2, 0x57,
	0xbb, 0xe7, 0x9c, 0x6f, 0xe7, 0x3b, 0x7b, 0x0e, 0x03, 0x9d, 0xd1, 0x62, 0x86, 0xa1, 0xd2, 0x74,
	0x84, 0x99, 0x0a, 0x67, 0x07, 0x03, 0xd4, 0xf4, 0xa0, 0xc0, 0xdd, 0x49, 0x26, 0xb5, 0x24, 0x6d,
	0x33, 0xd3, 0x2d, 0xb8, 0x7c, 0x66, 0xab, 0x9d, 0xc8, 0x44, 0xda, 0x81, 0xd0, 0xbc, 0xb9, 0xd9,
	0xce, 0xb7, 0x0d, 0xa8, 0x9f, 0xd9, 0x49, 0xe2, 0x43, 0x83, 0xc6, 0x71, 0x86, 0x4a, 0xf9, 0xde,
	0xae, 0xb7, 0xd7, 0x8a, 0x0a, 0x48, 0x4e, 0x01, 0x98, 0x1c, 0x8f, 0xb9, 0x52, 0x5c, 0x0a, 0x7f,
	0xc3, 0x88, 0x87, 0xdd, 0xcb, 0xeb, 0x9d, 0xca, 0xcf, 0xeb, 0x9d, 0xe7, 0x09, 0xd7, 0xc3, 0xe9,
	0xa0, 0xcb, 0xe4, 0x38, 0x64, 0x52, 0x8d, 0xa5, 0xca, 0x1f, 0xfb, 0x2a, 0x1e, 0x85, 0x7a, 0x31,
	0x41, 0xd5, 0x3d, 0x42, 0x16, 0x95, 0x4e, 0x30, 0x9b, 0xc6, 0x52, 0xf0, 0x11, 0x66, 0x7e, 0xd5,
	0x6d, 0xca, 0xa1, 0x51, 0xe6, 0x38, 0x50, 0x5c, 0xa3, 0x5f, 0x73, 0x4a, 0x0e, 0xc9, 0x16, 0x34,
	0x79, 0x8c, 0x42, 0x73, 0xbd, 0xf0, 0x37, 0xad, 0xb4, 0xc6, 0xe4, 0x05, 0x3c, 0x50, 0xc8, 0xa6,
	0x19, 0xd7, 0x8b, 0x3e, 0x93, 0x42, 0x53, 0xa6, 0xfd, 0xba, 0x9d, 0xb9, 0x5f, 0xf0, 0x3d, 0x47,
	0x9b, 0x05, 0x31, 0x6a, 0xca, 0x53, 0xe5, 0x37, 0xdc, 0x82, 0x1c, 0x92, 0x7d, 0x20, 0x37, 0x16,
	0xfb, 0x19, 0xce, 0x69, 0x16, 0x2b, 0xbf, 0xb9, 0xeb, 0xed, 0xd5, 0xa2, 0x87, 0x37, 0x4a, 0xe4,
	0x84, 0xce, 0x57, 0x0f, 0xe0, 0x9c, 0xa6, 0x94, 0x31, 0x39, 0x15, 0x9a, 0x3c, 0x81, 0xc6, 0x44,
	0xca, 0xb4, 0xcf, 0x63, 0x1b, 0x5e, 0x2d, 0xaa, 0x1b, 0x78, 0x12, 0x93, 0xc7, 0x50, 0x77, 0x4d,
	0xb8, 0xdc, 0xa2, 0x1c, 0x91, 0x00, 0x60, 0x46, 0xd3, 0x22, 0x70, 0x17, 0x43, 0x89, 0x31, 0xdf,
	0x4d, 0x24, 0x17, 0x5a, 0xd9, 0x20, 0xec, 0x79, 0x06, 0x91, 0x6d, 0x00, 0xae, 0xfa, 0x29, 0xd2,
	0x19, 0x17, 0x89, 0x4d, 0xa2, 0x19, 0xb5, 0xb8, 0x7a, 0xe7, 0x88, 0xce, 0x77, 0x0f, 0x1e, 0xf5,
	0xd6, 0x66, 0x7b, 0x43, 0x2a, 0x12, 0x3c, 0x16, 0x3a, 0x5b, 0x90, 0x36, 0x6c, 0x72, 0x11, 0xe3,
	0x45, 0xee, 0xcf, 0x81, 0x3f, 0xda, 0xbb, 0x5d, 0x79, 0xf5, 0xbf, 0x2b, 0x7f, 0x06, 0x77, 0x59,
	0x86, 0x54, 0x9b, 0x6c, 0x63, 0x9a, 0xd7, 0x5b, 0x8d, 0xee, 0x14, 0xe4, 0x11, 0xd5, 0xd8, 0xf9,
	0x0c, 0xf7, 0xcc, 0x7f, 0xe0, 0x7b, 0x29, 0xd3, 0x7f, 0x31, 0x5d, 0x2a, 0xa1, 0x7a, 0xab, 0x84,
	0xbf, 0xda, 0xfe, 0x06, 0xe0, 0xc3, 0x14, 0xa7, 0x78, 0xa6, 0xa9, 0x46, 0xf2, 0x14, 0x5a, 0xa9,
	0x9c, 0xf7, 0xcb, 0xdb, 0x9b, 0xa9, 0x9c, 0x9f, 0x58, 0x03, 0xdb, 0x00, 0x43, 0x9e, 0x0c, 0x73,
	0x75, 0xc3, 0xaa, 0x2d, 0xc3, 0x58, 0xf9, 0xf0, 0xf5, 0xe5, 0x32, 0xf0, 0xae, 0x96, 0x81, 0xf7,
	0x6b, 0x19, 0x78, 0x5f, 0x56, 0x41, 0xe5, 0x6a, 0x15, 0x54, 0x7e, 0xac, 0x82, 0xca, 0xa7, 0x97,
	0xa5, 0xe8, 0xde, 0x7e, 0x3c, 0x3f, 0x3e, 0x45, 0x3d, 0x97, 0xd9, 0x28, 0x64, 0x43, 0xca, 0x45,
	0x78, 0xb1, 0xbe, 0xd8, 0x36, 0xc4, 0x41, 0xdd, 0xde, 0xd1, 0x57, 0xbf, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x97, 0x01, 0x39, 0x24, 0xf5, 0x03, 0x00, 0x00,
}

func (m *Staker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Staker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Staker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommissionRewards != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CommissionRewards))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SecurityContact) > 0 {
		i -= len(m.SecurityContact)
		copy(dAtA[i:], m.SecurityContact)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.SecurityContact)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Valaccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Valaccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Valaccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLeaving {
		i--
		if m.IsLeaving {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Points != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Points))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Valaddress) > 0 {
		i -= len(m.Valaddress)
		copy(dAtA[i:], m.Valaddress)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Valaddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommissionChangeEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommissionChangeEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommissionChangeEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationDate != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CreationDate))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeavePoolEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeavePoolEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeavePoolEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationDate != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CreationDate))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueueState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighIndex != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.HighIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.LowIndex != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.LowIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStakers(dAtA []byte, offset int, v uint64) int {
	offset -= sovStakers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Staker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = m.Commission.Size()
	n += 1 + l + sovStakers(uint64(l))
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.SecurityContact)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.CommissionRewards != 0 {
		n += 1 + sovStakers(uint64(m.CommissionRewards))
	}
	return n
}

func (m *Valaccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Valaddress)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.Points != 0 {
		n += 1 + sovStakers(uint64(m.Points))
	}
	if m.IsLeaving {
		n += 2
	}
	return n
}

func (m *CommissionChangeEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStakers(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = m.Commission.Size()
	n += 1 + l + sovStakers(uint64(l))
	if m.CreationDate != 0 {
		n += 1 + sovStakers(uint64(m.CreationDate))
	}
	return n
}

func (m *LeavePoolEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStakers(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	if m.CreationDate != 0 {
		n += 1 + sovStakers(uint64(m.CreationDate))
	}
	return n
}

func (m *QueueState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowIndex != 0 {
		n += 1 + sovStakers(uint64(m.LowIndex))
	}
	if m.HighIndex != 0 {
		n += 1 + sovStakers(uint64(m.HighIndex))
	}
	return n
}

func sovStakers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStakers(x uint64) (n int) {
	return sovStakers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Staker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Staker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Staker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityContact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommissionRewards", wireType)
			}
			m.CommissionRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommissionRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Valaccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Valaccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Valaccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valaddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Valaddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeaving", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeaving = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommissionChangeEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommissionChangeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommissionChangeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			m.CreationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeavePoolEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeavePoolEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeavePoolEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			m.CreationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIndex", wireType)
			}
			m.LowIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighIndex", wireType)
			}
			m.HighIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStakers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStakers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStakers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStakers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStakers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStakers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStakers = fmt.Errorf("proto: unexpected end of group")
)
