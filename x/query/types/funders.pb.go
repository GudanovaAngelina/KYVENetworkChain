// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/query/v1beta1/funders.proto

package types

import (
	context "context"
	fmt "fmt"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Funder ...
type Funder struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// moniker ...
	Moniker string `protobuf:"bytes,2,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// identity is the 64 bit keybase.io identity string
	Identity string `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
	// logo ...
	Logo string `protobuf:"bytes,4,opt,name=logo,proto3" json:"logo,omitempty"`
	// website ...
	Website string `protobuf:"bytes,5,opt,name=website,proto3" json:"website,omitempty"`
	// contact ...
	Contact string `protobuf:"bytes,6,opt,name=contact,proto3" json:"contact,omitempty"`
	// description ...
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *Funder) Reset()         { *m = Funder{} }
func (m *Funder) String() string { return proto.CompactTextString(m) }
func (*Funder) ProtoMessage()    {}
func (*Funder) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{0}
}
func (m *Funder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Funder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Funder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Funder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Funder.Merge(m, src)
}
func (m *Funder) XXX_Size() int {
	return m.Size()
}
func (m *Funder) XXX_DiscardUnknown() {
	xxx_messageInfo_Funder.DiscardUnknown(m)
}

var xxx_messageInfo_Funder proto.InternalMessageInfo

func (m *Funder) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Funder) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Funder) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Funder) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

func (m *Funder) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Funder) GetContact() string {
	if m != nil {
		return m.Contact
	}
	return ""
}

func (m *Funder) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// FunderStats ...
type FunderStats struct {
	// total_used_funds are the total funds that have been distributed by the funder.
	TotalUsedFunds uint64 `protobuf:"varint,1,opt,name=total_used_funds,json=totalUsedFunds,proto3" json:"total_used_funds,omitempty"`
	// total_allocated_funds are the total funds that have been allocated by the funder. They can either get distributed or refunded.
	TotalAllocatedFunds uint64 `protobuf:"varint,2,opt,name=total_allocated_funds,json=totalAllocatedFunds,proto3" json:"total_allocated_funds,omitempty"`
	// pools_funded are the ids of the pools that have been funded by the funder.
	PoolsFunded []uint64 `protobuf:"varint,3,rep,packed,name=pools_funded,json=poolsFunded,proto3" json:"pools_funded,omitempty"`
}

func (m *FunderStats) Reset()         { *m = FunderStats{} }
func (m *FunderStats) String() string { return proto.CompactTextString(m) }
func (*FunderStats) ProtoMessage()    {}
func (*FunderStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{1}
}
func (m *FunderStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunderStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FunderStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FunderStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunderStats.Merge(m, src)
}
func (m *FunderStats) XXX_Size() int {
	return m.Size()
}
func (m *FunderStats) XXX_DiscardUnknown() {
	xxx_messageInfo_FunderStats.DiscardUnknown(m)
}

var xxx_messageInfo_FunderStats proto.InternalMessageInfo

func (m *FunderStats) GetTotalUsedFunds() uint64 {
	if m != nil {
		return m.TotalUsedFunds
	}
	return 0
}

func (m *FunderStats) GetTotalAllocatedFunds() uint64 {
	if m != nil {
		return m.TotalAllocatedFunds
	}
	return 0
}

func (m *FunderStats) GetPoolsFunded() []uint64 {
	if m != nil {
		return m.PoolsFunded
	}
	return nil
}

// Funding ...
type Funding struct {
	// pool_id ...
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount ...
	Amount uint64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// amount_per_bundle ...
	AmountPerBundle uint64 `protobuf:"varint,3,opt,name=amount_per_bundle,json=amountPerBundle,proto3" json:"amount_per_bundle,omitempty"`
	// total_funded ...
	TotalFunded uint64 `protobuf:"varint,4,opt,name=total_funded,json=totalFunded,proto3" json:"total_funded,omitempty"`
}

func (m *Funding) Reset()         { *m = Funding{} }
func (m *Funding) String() string { return proto.CompactTextString(m) }
func (*Funding) ProtoMessage()    {}
func (*Funding) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{2}
}
func (m *Funding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Funding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Funding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Funding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Funding.Merge(m, src)
}
func (m *Funding) XXX_Size() int {
	return m.Size()
}
func (m *Funding) XXX_DiscardUnknown() {
	xxx_messageInfo_Funding.DiscardUnknown(m)
}

var xxx_messageInfo_Funding proto.InternalMessageInfo

func (m *Funding) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Funding) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Funding) GetAmountPerBundle() uint64 {
	if m != nil {
		return m.AmountPerBundle
	}
	return 0
}

func (m *Funding) GetTotalFunded() uint64 {
	if m != nil {
		return m.TotalFunded
	}
	return 0
}

// QueryFundersRequest is the request type for the Query/Funders RPC method.
type QueryFundersRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// search ...
	Search string `protobuf:"bytes,2,opt,name=search,proto3" json:"search,omitempty"`
}

func (m *QueryFundersRequest) Reset()         { *m = QueryFundersRequest{} }
func (m *QueryFundersRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFundersRequest) ProtoMessage()    {}
func (*QueryFundersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{3}
}
func (m *QueryFundersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundersRequest.Merge(m, src)
}
func (m *QueryFundersRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundersRequest proto.InternalMessageInfo

func (m *QueryFundersRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundersRequest) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

// QueryFundersResponse is the response type for the Query/Funders RPC method.
type QueryFundersResponse struct {
	// funders ...
	Funders []Funder `protobuf:"bytes,1,rep,name=funders,proto3" json:"funders"`
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryFundersResponse) Reset()         { *m = QueryFundersResponse{} }
func (m *QueryFundersResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFundersResponse) ProtoMessage()    {}
func (*QueryFundersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{4}
}
func (m *QueryFundersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundersResponse.Merge(m, src)
}
func (m *QueryFundersResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundersResponse proto.InternalMessageInfo

func (m *QueryFundersResponse) GetFunders() []Funder {
	if m != nil {
		return m.Funders
	}
	return nil
}

func (m *QueryFundersResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryFunderRequest is the request type for the Query/Funder RPC method.
type QueryFunderRequest struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// with_inactive_fundings ...
	WithInactiveFundings bool `protobuf:"varint,2,opt,name=with_inactive_fundings,json=withInactiveFundings,proto3" json:"with_inactive_fundings,omitempty"`
}

func (m *QueryFunderRequest) Reset()         { *m = QueryFunderRequest{} }
func (m *QueryFunderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFunderRequest) ProtoMessage()    {}
func (*QueryFunderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{5}
}
func (m *QueryFunderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFunderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFunderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFunderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFunderRequest.Merge(m, src)
}
func (m *QueryFunderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFunderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFunderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFunderRequest proto.InternalMessageInfo

func (m *QueryFunderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryFunderRequest) GetWithInactiveFundings() bool {
	if m != nil {
		return m.WithInactiveFundings
	}
	return false
}

// QueryFunderResponse is the response type for the Query/Funder RPC method.
type QueryFunderResponse struct {
	// funder ...
	Funder *Funder `protobuf:"bytes,1,opt,name=funder,proto3" json:"funder,omitempty"`
	// fundings ...
	Fundings []Funding `protobuf:"bytes,2,rep,name=fundings,proto3" json:"fundings"`
	// stats ...
	Stats *FunderStats `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
}

func (m *QueryFunderResponse) Reset()         { *m = QueryFunderResponse{} }
func (m *QueryFunderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFunderResponse) ProtoMessage()    {}
func (*QueryFunderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{6}
}
func (m *QueryFunderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFunderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFunderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFunderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFunderResponse.Merge(m, src)
}
func (m *QueryFunderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFunderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFunderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFunderResponse proto.InternalMessageInfo

func (m *QueryFunderResponse) GetFunder() *Funder {
	if m != nil {
		return m.Funder
	}
	return nil
}

func (m *QueryFunderResponse) GetFundings() []Funding {
	if m != nil {
		return m.Fundings
	}
	return nil
}

func (m *QueryFunderResponse) GetStats() *FunderStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func init() {
	proto.RegisterType((*Funder)(nil), "kyve.query.v1beta1.Funder")
	proto.RegisterType((*FunderStats)(nil), "kyve.query.v1beta1.FunderStats")
	proto.RegisterType((*Funding)(nil), "kyve.query.v1beta1.Funding")
	proto.RegisterType((*QueryFundersRequest)(nil), "kyve.query.v1beta1.QueryFundersRequest")
	proto.RegisterType((*QueryFundersResponse)(nil), "kyve.query.v1beta1.QueryFundersResponse")
	proto.RegisterType((*QueryFunderRequest)(nil), "kyve.query.v1beta1.QueryFunderRequest")
	proto.RegisterType((*QueryFunderResponse)(nil), "kyve.query.v1beta1.QueryFunderResponse")
}

func init() { proto.RegisterFile("kyve/query/v1beta1/funders.proto", fileDescriptor_a182f068d9f0dba9) }

var fileDescriptor_a182f068d9f0dba9 = []byte{
	// 737 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xcf, 0x6b, 0x13, 0x4d,
	0x18, 0xce, 0x26, 0x69, 0xd2, 0x6f, 0xb6, 0x7c, 0xdf, 0xe7, 0xb4, 0xd6, 0x25, 0xd5, 0x34, 0xae,
	0xd2, 0x86, 0x22, 0xbb, 0x34, 0xea, 0x45, 0xf0, 0x60, 0xd1, 0x4a, 0x11, 0xa4, 0xae, 0x28, 0xe8,
	0x25, 0x4c, 0x76, 0xc7, 0xcd, 0xd0, 0xcd, 0xcc, 0x76, 0x67, 0xb6, 0x35, 0x88, 0x07, 0xbd, 0x88,
	0x17, 0x11, 0x3c, 0xea, 0xff, 0x22, 0x78, 0xea, 0xb1, 0xe0, 0xc5, 0x93, 0x48, 0xeb, 0x1f, 0x22,
	0xf3, 0x23, 0x69, 0xa2, 0x8d, 0xb9, 0xcd, 0xfb, 0x3e, 0xcf, 0x3b, 0xf3, 0xcc, 0xb3, 0xcf, 0x0e,
	0x68, 0xec, 0xf4, 0xf7, 0xb0, 0xbf, 0x9b, 0xe3, 0xac, 0xef, 0xef, 0xad, 0x77, 0xb0, 0x40, 0xeb,
	0xfe, 0xb3, 0x9c, 0x46, 0x38, 0xe3, 0x5e, 0x9a, 0x31, 0xc1, 0x20, 0x94, 0x0c, 0x4f, 0x31, 0x3c,
	0xc3, 0xa8, 0xad, 0x85, 0x8c, 0xf7, 0x18, 0xf7, 0x3b, 0x88, 0xff, 0x3e, 0x9c, 0xa2, 0x98, 0x50,
	0x24, 0x08, 0xa3, 0x7a, 0xbe, 0xb6, 0x10, 0xb3, 0x98, 0xa9, 0xa5, 0x2f, 0x57, 0xa6, 0x7b, 0x3e,
	0x66, 0x2c, 0x4e, 0xb0, 0x8f, 0x52, 0xe2, 0x23, 0x4a, 0x99, 0x50, 0x23, 0xe6, 0x4c, 0xf7, 0x8b,
	0x05, 0x2a, 0x9b, 0x4a, 0x05, 0x74, 0x40, 0x15, 0x45, 0x51, 0x86, 0x39, 0x77, 0xac, 0x86, 0xd5,
	0xfc, 0x27, 0x18, 0x94, 0x12, 0xe9, 0x31, 0x4a, 0x76, 0x70, 0xe6, 0x14, 0x35, 0x62, 0x4a, 0x58,
	0x03, 0xb3, 0x24, 0xc2, 0x54, 0x10, 0xd1, 0x77, 0x4a, 0x0a, 0x1a, 0xd6, 0x10, 0x82, 0x72, 0xc2,
	0x62, 0xe6, 0x94, 0x55, 0x5f, 0xad, 0xe5, 0x4e, 0xfb, 0xb8, 0xc3, 0x89, 0xc0, 0xce, 0x8c, 0xde,
	0xc9, 0x94, 0x12, 0x09, 0x19, 0x15, 0x28, 0x14, 0x4e, 0x45, 0x23, 0xa6, 0x84, 0x0d, 0x60, 0x47,
	0x98, 0x87, 0x19, 0x49, 0xa5, 0x70, 0xa7, 0xaa, 0xd0, 0xd1, 0x96, 0xfb, 0xce, 0x02, 0xb6, 0xbe,
	0xc4, 0x43, 0x81, 0x04, 0x87, 0x4d, 0xf0, 0xbf, 0x60, 0x02, 0x25, 0xed, 0x9c, 0xe3, 0xa8, 0x2d,
	0x4d, 0xd6, 0x57, 0x2a, 0x07, 0xff, 0xaa, 0xfe, 0x23, 0x8e, 0x23, 0xc9, 0xe7, 0xb0, 0x05, 0xce,
	0x6a, 0x26, 0x4a, 0x12, 0x16, 0x22, 0x31, 0xa4, 0x17, 0x15, 0x7d, 0x5e, 0x81, 0xb7, 0x06, 0x98,
	0x9e, 0xb9, 0x08, 0xe6, 0x52, 0xc6, 0x12, 0xae, 0x98, 0x38, 0x72, 0x4a, 0x8d, 0x52, 0xb3, 0x1c,
	0xd8, 0xaa, 0xa7, 0x54, 0x44, 0xee, 0x5b, 0x0b, 0x54, 0xe5, 0x92, 0xd0, 0x18, 0x9e, 0x03, 0x55,
	0x09, 0xb5, 0x49, 0x64, 0x34, 0x54, 0x64, 0xb9, 0x15, 0xc1, 0x45, 0x50, 0x41, 0x3d, 0x96, 0x53,
	0x61, 0x0e, 0x33, 0x15, 0x5c, 0x03, 0x67, 0xf4, 0xaa, 0x9d, 0xe2, 0xac, 0xdd, 0xc9, 0x69, 0x94,
	0x60, 0x65, 0x6e, 0x39, 0xf8, 0x4f, 0x03, 0xdb, 0x38, 0xdb, 0x50, 0x6d, 0xa9, 0x45, 0xeb, 0x37,
	0x5a, 0xca, 0x8a, 0x66, 0xab, 0x9e, 0xd1, 0x92, 0x83, 0xf9, 0x07, 0x32, 0x37, 0xda, 0x20, 0x1e,
	0xe0, 0xdd, 0x1c, 0x73, 0x01, 0x37, 0x01, 0x38, 0x09, 0x90, 0x52, 0x66, 0xb7, 0x56, 0x3c, 0x9d,
	0x36, 0x4f, 0xa6, 0x6d, 0x3c, 0x88, 0xde, 0x36, 0x8a, 0xb1, 0x99, 0x0d, 0x46, 0x26, 0xe5, 0x2d,
	0x38, 0x46, 0x59, 0xd8, 0x35, 0xd1, 0x30, 0x95, 0xfb, 0xd1, 0x02, 0x0b, 0xe3, 0xe7, 0xf2, 0x94,
	0x51, 0x8e, 0xe1, 0x0d, 0x50, 0x35, 0xb1, 0x77, 0xac, 0x46, 0xa9, 0x69, 0xb7, 0x6a, 0xde, 0x9f,
	0xb9, 0xf7, 0xf4, 0xd4, 0x46, 0xf9, 0xe0, 0xfb, 0x72, 0x21, 0x18, 0x0c, 0xc0, 0xbb, 0x63, 0xa2,
	0x8b, 0x4a, 0xf4, 0xea, 0x54, 0xd1, 0xfa, 0xe0, 0x51, 0xd5, 0x6e, 0x04, 0xe0, 0x88, 0xb8, 0x81,
	0x27, 0x93, 0xff, 0x80, 0x6b, 0x60, 0x71, 0x9f, 0x88, 0x6e, 0x9b, 0x50, 0x14, 0x0a, 0xb2, 0x87,
	0x95, 0xdf, 0x84, 0xc6, 0x3a, 0x28, 0xb3, 0xc1, 0x82, 0x44, 0xb7, 0x0c, 0x68, 0xbe, 0x3c, 0x77,
	0x3f, 0x5b, 0x63, 0xde, 0x0f, 0x2d, 0x68, 0x81, 0x8a, 0xbe, 0x91, 0xf1, 0xfd, 0x2f, 0x0e, 0x04,
	0x86, 0x09, 0x6f, 0x82, 0xd9, 0x91, 0x33, 0xa5, 0x6f, 0x4b, 0x93, 0xa6, 0x08, 0x8d, 0x8d, 0x71,
	0xc3, 0x11, 0x78, 0x1d, 0xcc, 0x70, 0xf9, 0x6f, 0xa8, 0x20, 0xd9, 0xad, 0xe5, 0xc9, 0x27, 0xaa,
	0x5f, 0x28, 0xd0, 0xec, 0xd6, 0xa7, 0x22, 0x98, 0x1b, 0xfd, 0x8a, 0xf0, 0x95, 0x49, 0xb6, 0x5c,
	0xaf, 0x9e, 0xb6, 0xc9, 0x29, 0x59, 0xab, 0x35, 0xa7, 0x13, 0xb5, 0x33, 0xee, 0xa5, 0xd7, 0x5f,
	0x7f, 0x7e, 0x28, 0x5e, 0x80, 0x4b, 0xfe, 0xe4, 0xd7, 0x12, 0xbe, 0x39, 0x79, 0xb3, 0x56, 0xa6,
	0xec, 0x3c, 0x50, 0xb0, 0x3a, 0x95, 0x67, 0x04, 0x5c, 0x51, 0x02, 0x56, 0xe0, 0xe5, 0xc9, 0x02,
	0xfc, 0x17, 0x26, 0x15, 0x2f, 0x37, 0x6e, 0x1f, 0x1c, 0xd5, 0xad, 0xc3, 0xa3, 0xba, 0xf5, 0xe3,
	0xa8, 0x6e, 0xbd, 0x3f, 0xae, 0x17, 0x0e, 0x8f, 0xeb, 0x85, 0x6f, 0xc7, 0xf5, 0xc2, 0xd3, 0xb5,
	0x98, 0x88, 0x6e, 0xde, 0xf1, 0x42, 0xd6, 0xf3, 0xef, 0x3d, 0x79, 0x7c, 0xe7, 0x3e, 0x16, 0xfb,
	0x2c, 0xdb, 0xf1, 0xc3, 0x2e, 0x22, 0xd4, 0x7f, 0x6e, 0x36, 0x16, 0xfd, 0x14, 0xf3, 0x4e, 0x45,
	0x3d, 0xc5, 0x57, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0xf3, 0x64, 0x62, 0xc8, 0x22, 0x06, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryFundersClient is the client API for QueryFunders service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryFundersClient interface {
	// Funders queries all funders.
	Funders(ctx context.Context, in *QueryFundersRequest, opts ...grpc.CallOption) (*QueryFundersResponse, error)
	// Funder queries a funder by address.
	Funder(ctx context.Context, in *QueryFunderRequest, opts ...grpc.CallOption) (*QueryFunderResponse, error)
}

type queryFundersClient struct {
	cc grpc1.ClientConn
}

func NewQueryFundersClient(cc grpc1.ClientConn) QueryFundersClient {
	return &queryFundersClient{cc}
}

func (c *queryFundersClient) Funders(ctx context.Context, in *QueryFundersRequest, opts ...grpc.CallOption) (*QueryFundersResponse, error) {
	out := new(QueryFundersResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryFunders/Funders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryFundersClient) Funder(ctx context.Context, in *QueryFunderRequest, opts ...grpc.CallOption) (*QueryFunderResponse, error) {
	out := new(QueryFunderResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryFunders/Funder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryFundersServer is the server API for QueryFunders service.
type QueryFundersServer interface {
	// Funders queries all funders.
	Funders(context.Context, *QueryFundersRequest) (*QueryFundersResponse, error)
	// Funder queries a funder by address.
	Funder(context.Context, *QueryFunderRequest) (*QueryFunderResponse, error)
}

// UnimplementedQueryFundersServer can be embedded to have forward compatible implementations.
type UnimplementedQueryFundersServer struct {
}

func (*UnimplementedQueryFundersServer) Funders(ctx context.Context, req *QueryFundersRequest) (*QueryFundersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Funders not implemented")
}
func (*UnimplementedQueryFundersServer) Funder(ctx context.Context, req *QueryFunderRequest) (*QueryFunderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Funder not implemented")
}

func RegisterQueryFundersServer(s grpc1.Server, srv QueryFundersServer) {
	s.RegisterService(&_QueryFunders_serviceDesc, srv)
}

func _QueryFunders_Funders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFundersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryFundersServer).Funders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryFunders/Funders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryFundersServer).Funders(ctx, req.(*QueryFundersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryFunders_Funder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFunderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryFundersServer).Funder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryFunders/Funder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryFundersServer).Funder(ctx, req.(*QueryFunderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryFunders_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kyve.query.v1beta1.QueryFunders",
	HandlerType: (*QueryFundersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Funders",
			Handler:    _QueryFunders_Funders_Handler,
		},
		{
			MethodName: "Funder",
			Handler:    _QueryFunders_Funder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kyve/query/v1beta1/funders.proto",
}

func (m *Funder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Funder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Funder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Contact) > 0 {
		i -= len(m.Contact)
		copy(dAtA[i:], m.Contact)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Contact)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Logo) > 0 {
		i -= len(m.Logo)
		copy(dAtA[i:], m.Logo)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Logo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FunderStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunderStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunderStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolsFunded) > 0 {
		dAtA2 := make([]byte, len(m.PoolsFunded)*10)
		var j1 int
		for _, num := range m.PoolsFunded {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFunders(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.TotalAllocatedFunds != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.TotalAllocatedFunds))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalUsedFunds != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.TotalUsedFunds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Funding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Funding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Funding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalFunded != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.TotalFunded))
		i--
		dAtA[i] = 0x20
	}
	if m.AmountPerBundle != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.AmountPerBundle))
		i--
		dAtA[i] = 0x18
	}
	if m.Amount != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Funders) > 0 {
		for iNdEx := len(m.Funders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Funders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryFunderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFunderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFunderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithInactiveFundings {
		i--
		if m.WithInactiveFundings {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFunderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFunderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFunderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Fundings) > 0 {
		for iNdEx := len(m.Fundings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fundings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Funder != nil {
		{
			size, err := m.Funder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFunders(dAtA []byte, offset int, v uint64) int {
	offset -= sovFunders(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Funder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Contact)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	return n
}

func (m *FunderStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalUsedFunds != 0 {
		n += 1 + sovFunders(uint64(m.TotalUsedFunds))
	}
	if m.TotalAllocatedFunds != 0 {
		n += 1 + sovFunders(uint64(m.TotalAllocatedFunds))
	}
	if len(m.PoolsFunded) > 0 {
		l = 0
		for _, e := range m.PoolsFunded {
			l += sovFunders(uint64(e))
		}
		n += 1 + sovFunders(uint64(l)) + l
	}
	return n
}

func (m *Funding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovFunders(uint64(m.PoolId))
	}
	if m.Amount != 0 {
		n += 1 + sovFunders(uint64(m.Amount))
	}
	if m.AmountPerBundle != 0 {
		n += 1 + sovFunders(uint64(m.AmountPerBundle))
	}
	if m.TotalFunded != 0 {
		n += 1 + sovFunders(uint64(m.TotalFunded))
	}
	return n
}

func (m *QueryFundersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	return n
}

func (m *QueryFundersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Funders) > 0 {
		for _, e := range m.Funders {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	return n
}

func (m *QueryFunderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	if m.WithInactiveFundings {
		n += 2
	}
	return n
}

func (m *QueryFunderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Funder != nil {
		l = m.Funder.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	if len(m.Fundings) > 0 {
		for _, e := range m.Fundings {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	return n
}

func sovFunders(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFunders(x uint64) (n int) {
	return sovFunders(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Funder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Funder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Funder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunderStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunderStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunderStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsedFunds", wireType)
			}
			m.TotalUsedFunds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsedFunds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAllocatedFunds", wireType)
			}
			m.TotalAllocatedFunds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAllocatedFunds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFunders
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PoolsFunded = append(m.PoolsFunded, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFunders
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFunders
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFunders
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PoolsFunded) == 0 {
					m.PoolsFunded = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFunders
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PoolsFunded = append(m.PoolsFunded, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolsFunded", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Funding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Funding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Funding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountPerBundle", wireType)
			}
			m.AmountPerBundle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountPerBundle |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFunded", wireType)
			}
			m.TotalFunded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFunded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Funders = append(m.Funders, Funder{})
			if err := m.Funders[len(m.Funders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFunderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFunderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFunderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithInactiveFundings", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithInactiveFundings = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFunderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFunderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFunderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Funder == nil {
				m.Funder = &Funder{}
			}
			if err := m.Funder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fundings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fundings = append(m.Fundings, Funding{})
			if err := m.Fundings[len(m.Fundings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &FunderStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFunders(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFunders
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFunders
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFunders
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFunders        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFunders          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFunders = fmt.Errorf("proto: unexpected end of group")
)
